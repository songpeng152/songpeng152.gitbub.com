<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AIDL的开发]]></title>
    <url>%2F2018%2F10%2F08%2FAIDL%E7%9A%84%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[因为产品要求功能的开发，要做列表中做一个音频播放的功能，但是音频播放一般是放在另外一个Service中完成的，所以根据需求学习了AIDL的开发。 首先新建一个AIDL的文件夹在main目录下AIDL是一个interface的类型 interface IMusicControl { boolean isPlaying(); void pause(); void start(int position); int getDuration(); int getCurrenPostion(); void seekTo(int mesc); void create(String url,String audioName); void release(); void stop(); void unBind(); } 这个音乐控制类中主要是音频的控制。 第二步，新建Service在Service中新建一个MyBinder的内部类，继承IMusicControl.Stub public class MyBinder extends IMusicControl.Stub implements MediaPlayer.OnPreparedListener, MediaPlayer.OnErrorListener, MediaPlayer.OnCompletionListener, MediaPlayer.OnBufferingUpdateListener { //判断是否处于播放状态 public boolean isPlaying() { if (player == null) { return false; } return player.isPlaying(); } //播放或暂停歌曲 public void pause() { MusicService.this.pause(); } @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN) public void start(int position) { if (position != -1) { MusicService.this.position = position; } MusicService.this.start(); } //返回歌曲的长度，单位为毫秒 public int getDuration() { if (player == null) { return -1; } return player.getDuration(); } //返回歌曲目前的进度，单位为毫秒 public int getCurrenPostion() { if (player == null) { return -1; } return player.getCurrentPosition(); } //设置歌曲播放的进度，单位为毫秒 public void seekTo(int mesc) { player.seekTo(mesc); } public void create(final String url, String audioName) { player = new MediaPlayer(); try { player.setDataSource(url); //准备资源 player.prepareAsync(); isCreate = true; player.setOnPreparedListener(MyBinder.this); player.setOnCompletionListener(MyBinder.this); player.setOnErrorListener(MyBinder.this); player.setOnInfoListener(new MediaPlayer.OnInfoListener() { @Override public boolean onInfo(MediaPlayer mp, int what, int extra) { Log.d(TAG, &quot;onInfo: &quot; + what); Log.d(TAG, &quot;onInfo: &quot; + extra); switch (what) { case MediaPlayer.MEDIA_INFO_BUFFERING_START: sendPrepare(position); break; case MediaPlayer.MEDIA_INFO_BUFFERING_END: Log.d(TAG, &quot;onInfo: end&quot;); sendPlay(position); break; } return false; } }); player.setOnBufferingUpdateListener(this); if (StringUtil.isNotNull(audioName)) { MusicService.this.audioName = audioName; } startPositionTimer(); Log.d(TAG, &quot;create: &quot;); } catch (IOException e) { e.printStackTrace(); } } public void release() { if (player != null) { if (positionTimer != null) { positionTimer.cancel(); positionTimer = null; } player.release(); } } public void stop() { if (player != null) { if (positionTimer != null) { positionTimer.cancel(); positionTimer = null; } player.stop(); isStop = true; isCreate = false; cancelNotification(); sendStop(position); } } @Override public void unBind() throws RemoteException { if (positionTimer != null) { positionTimer.cancel(); positionTimer = null; } if (player != null) { if (player.isPlaying()) { player.stop(); } player.release(); player = null; } } @Override public void onPrepared(MediaPlayer mp) { if (isCreate) { mp.start(); completion = false; sendPlay(position); startNotification(); Log.d(TAG, &quot;onPrepared: &quot;); } } @Override public boolean onError(MediaPlayer mp, int what, int extra) { Log.d(TAG, &quot;onError: &quot;); if (isStop) { return true; } sendError(position); return true; } @Override public void onCompletion(MediaPlayer mp) { if (percent == 100 &amp;&amp; mp.getDuration() &gt; 0) { sendCompletion(position); completion = true; Log.d(TAG, &quot;onCompletion: &quot; + mp.getDuration()); } } @Override public void onBufferingUpdate(MediaPlayer mp, int percent) { MusicService.this.percent = percent; } } 并且在onBind(Intent intent)方法中初始化MyBinder。然后在AndroidManifest文件中声明Service &lt;service android:name=&quot;.app.server.MusicService&quot; android:process=&quot;:music&quot; /&gt; 其中process是另启一个进程。此时新进程Service基本上已经搭建完成，剩下的是调用的事情了。 第三步 新建一个控制Service的类MediaControl在MediaControl类内部新建一个内部类MyConnection实现ServiceConnection接口 private class MyConnection implements ServiceConnection { //服务启动完成后会进入到这个方法 @Override public void onServiceConnected(ComponentName name, IBinder service) { //获得service中的MyBinder iMusicControl = IMusicControl.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { iMusicControl = null; } } 此时已经基本完成了AIDL的功能，只要通过之前定义的方法通过iMusicControl.方法就可以调用了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 4.4 kitkat SD卡下载地址的处理]]></title>
    <url>%2F2017%2F11%2F13%2FAndroid-SD%E5%8D%A1%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近工作遇到一个问题，学员想把下载的视频放到外置的SD卡上，所以领导要求开发一个这样的功能。因为历史的原因，android手机是可以安装外置的存储卡，用来分担内置存储卡放不下的东西，比如下载个视频、下载个音乐什么的，但是从android4.4（Kitkat）之后，谷歌可能觉得应用直接操作sd卡会让sd卡的文件太混乱了，所以应用不能直接操作sd卡了，那应用大的数据（优酷下个视频，网易下个音乐）怎么存储在sd卡中呢。what，这个问题纠结了好久，因为之前没有了解过这方面，当时开发也不知道android已经不让应用操作sd卡了，所以就一直在想怎么才能突破这个限制，一直就在突破方面想办法，后来就想看看ES文件管理器怎么操作sd卡的，我想它能操作，我为啥不能操作，就找怎么操作SD卡的方法，还别说真让我找到了，我看它会有一个页面提示，然后选择sd卡，就可以操作了。大概就是这样的,当发现别人好的代码，我们该怎么办呢，答案就是—–逆向工程，基于学习的目的，我反编译了Es的代码然后看它实现步骤： 1.如果发现有sd卡的地址，又发现写文件失败那就弹出这么个页面，引导用户进行这样的选择操作 2.获取到sd卡的uri路径 3.startActivityForResult(new Intent(&quot;android.intent.action.OPEN_DOCUMENT_TREE&quot;,code)); 4.处理返回的uri @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { case code: if (resultCode == RESULT_OK) { Uri treeUri = data.getData(); if (!&quot;:&quot;.equals(treeUri.getPath().substring(treeUri.getPath().length() - 1)) || treeUri.getPath().contains(&quot;primary&quot;)) { //这里继续弹出弹窗来提示用户获取uri } else { Log.d(TAG,&quot;onActivityResult&quot;+succeed); PageExtra.setSdUri(treeUri.toString()); } } } super.onActivityResult(requestCode, resultCode, data); } 5.现在其实已经可以操作SD卡了 我也找到了别人的博客，他写的比较详细，因为我最后也并不是要操作所有的sd卡，所以我也没有深入的学习。这时候我很高兴呀，终于找到了办法，任务完成了一半了，剩下的就是把下载地址放进去就ok了，然后一看xUtil,它不支持使用uri下载，而我如果自己要把xUtil的下载改一下应该不只是两天了，我这是觉得路走错了，继续找别的路走一下。 百度找不多就去google看一下，没想到一找就找到两篇一起的博客，一下我就懂了，现在把路径给大家，免的大家走弯路，这个是说4.4的,这个是说操作整个sd卡的。这时候我才知道了，android系统是不让操作整个sd卡，但是应用可以单独操作sdCard/Android/data/应用/xxx目录的，那其实问题已经很清楚了，就是以后只能放在外置sd卡下的固定目录，如果删除应用目录也会被删除，用户就不用担心应用残留数据了，这个应该是和iphone一样的思路。到这里其实我以为我已经搞定了，但是我没想一个很重要的问题，就是andorid系统的多厂商，当我写完代码一测，nnd，获取的sd卡路径不正确，而且感觉官方的文档没有固定获取内外置sd卡的固定方法，我又找了一下资料，发现一个比较好用的，是通过反射来获取的sd卡路径就是第二种方法。大部分的设备都是可以获取到正确的路径，但是尝试魅族 pro5时候不能下载，我觉的应该是路径获取错了，因为是别人的手机我也没有太多的测试，如果大家有好的获取sd卡路径的方法欢迎留言，共同进步。 欢迎大家关注我的简书。]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义view（四）之滴滴loading]]></title>
    <url>%2F2017%2F09%2F14%2F%E8%87%AA%E5%AE%9A%E4%B9%89view%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E6%BB%B4%E6%BB%B4loading%2F</url>
    <content type="text"><![CDATA[公司有个福利，就是每天晚上加班之后可以打车，然后每个月报销一次，感觉生活的幸福感都提升了，有木有，加班之后那么累正好打车，但是我住的比较偏呀，有时候看着滴滴那个转啊转就是没有车，老烦了，你就不能给我多通知几个车吗。正好学了自定义view那么自己手撸一个，嘿嘿。先上个图看看效果怎么样 看看是不是特别像滴滴的呢，除了车通知的太多了[捂脸]，到了上大餐的时候了，先说一下思路: 大概分成四部分： 不动的字比如：正在为您叫车，为您优先叫车，这个是可以用textView直接写的 需要在画布上写的，比如：已通知出租车，通知多少辆，“辆”，这些虽然可以用textView写然后套framelayout,但是这样需要调的地方比较多，所以还是自定义 基础的灰色的圆，转的橙色的圆 在圆上边一直转的那个圆 开始上代码了 mCirclePaint = new Paint(); mCirclePaint.setStrokeWidth(5); mCirclePaint.setColor(Color.parseColor(“#E3E4E7”)); mCirclePaint.setAntiAlias(true); mCirclePaint.setStyle(Paint.Style.STROKE); mTextPaint = new Paint(); mTextPaint.setStrokeWidth(1); mTextPaint.setColor(Color.parseColor(&quot;#8B8C8F&quot;)); mTextPaint.setAntiAlias(true); mTextPaint.setTextSize(20); mTextPaint.setStyle(Paint.Style.FILL); mTextCountPaint = new Paint(); mTextCountPaint.setStrokeWidth(1); mTextCountPaint.setColor(Color.parseColor(&quot;#EC9B70&quot;)); mTextCountPaint.setAntiAlias(true); mTextCountPaint.setTextSize(40); mTextCountPaint.setStyle(Paint.Style.FILL); mTextUnitPaint = new Paint(); mTextUnitPaint.setStrokeWidth(1); mTextUnitPaint.setColor(Color.parseColor(&quot;#EC9B70&quot;)); mTextUnitPaint.setAntiAlias(true); mTextUnitPaint.setTextSize(20); mTextUnitPaint.setStyle(Paint.Style.FILL); mDrawArcPaint = new Paint(); mDrawArcPaint.setStrokeWidth(5); mDrawArcPaint.setAntiAlias(true); mDrawArcPaint.setStyle(Paint.Style.STROKE); pos = new float[2]; tan = new float[2]; BitmapFactory.Options options = new BitmapFactory.Options();//通过bitmapFactory获取图片资源 mBitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.point,options);//获取资源 mMatrix = new Matrix(); 这次我先设置了多个画笔，这样就不用每次绘制不同的宽度或颜色的图形就要重新设置画笔了，但是这样就有一个问题，成员变量太多了，会占用比较大的内存（这里我要吐槽一下我，我有一个A同事，还有一个B同事，A同事说你为啥方法里用局部变量不用成员变量，B同事说我这个只是在方法中调用，所以用局部变量，A同事说你这个写的不对，真是不知道怎么说这个A同事了），如果项目中还是尽量少写成员变量，而选择的用局部变量。 现在就是开始画了圆了 @Override protected void onDraw(Canvas canvas) { canvas.translate(mWidth/2,mHeight/2);//把画布移到屏幕的中心 rectF = new RectF(-mWidth/2+50,-mWidth/2+50,mWidth/2-50,mWidth/2-50); Path path = new Path(); path.addCircle(0,0,(mWidth-100)/2, Path.Direction.CW);//cw是顺时针 canvas.drawPath(path,mCirclePaint);//顺时针的画一个圆 PathMeasure measure = new PathMeasure(path, false); // 创建 PathMeasure,这是测试path的 BigDecimal bigDecimal1 = BigDecimal.valueOf(sweepAngle); BigDecimal b2 = BigDecimal.valueOf(360); float rad = bigDecimal1.divide(b2,MathContext.DECIMAL32).floatValue();//通过bigdecimal来获取黄线在灰色圆上的位置，在放黄色的小球 measure.getPosTan(measure.getLength() * rad +10, pos, tan);// 获取当前位置的坐标以及趋势 mMatrix.reset(); // 重置Matrix float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); // 计算图片旋转角度 mMatrix.postRotate(degrees, mBitmap.getWidth() / 2, mBitmap.getHeight() / 2); // 旋转图片 mMatrix.postTranslate(pos[0] - mBitmap.getWidth() / 2, pos[1] - mBitmap.getHeight() / 2); // 将图片绘制中心调整到与当前点重合 Rect rect = new Rect(); mTextPaint.getTextBounds(notification,0,notification.length(),rect); canvas.drawText(notification,-(rect.left+rect.right)/2,rect.bottom,mTextPaint);//写通知的字 Rect rectCount = new Rect(); mTextCountPaint.getTextBounds(String.valueOf(sweepAngle),0,String.valueOf(sweepAngle).length(),rectCount); canvas.drawText(String.valueOf(sweepAngle),-(rect.left+rect.right)/2,rect.bottom-rect.top-rect.bottom-rectCount.top/*-rectCount.bottom*/,mTextCountPaint);//写车的数量 canvas.drawText(unit,(rect.left-rect.right)/2+100,rect.bottom-rect.top-rect.bottom-rectCount.top/*-rectCount.bottom*/,mTextUnitPaint);//写车的单位 // Log.d(TAG, &quot;onDraw: y= &quot;+(-rect.top-rectCount.top-rectCount.bottom)); // Log.d(TAG, &quot;onDraw: rect.top &quot;+rect.top); // Log.d(TAG, &quot;onDraw: rectCount.top &quot;+rectCount.top); // Log.d(TAG, &quot;onDraw: rectCount.bottom &quot;+rectCount.bottom); mMatrix.postRotate(-90); canvas.drawBitmap(mBitmap, mMatrix, mDrawArcPaint); canvas.drawArc(rectF,-90,sweepAngle,false, mDrawArcPaint); } 思路也写到注释里边了，哈哈，注意看代码就可以了，然后这时候还不能动哩，要设置动怎么办呢，就是刷新，上次用了pos，这次用Timer+handler。 final Timer timer = new Timer(); TimerTask timeTask = new TimerTask() { @Override public void run() { if (i&gt;=360) { i = 0; } Message message = new Message(); message.what = 1; handler.sendMessage(message); } }; timer.schedule(timeTask,1000,100);//每100毫秒时候刷新一下，第三个参数 } Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { if (msg.what == 1) { diDiView.setData(i+=1); } super.handleMessage(msg); } }; 这就搞定了，然后你就看到通知了好多车就是没人来接[尴尬]。代码已经上传到我的git欢迎大家star和fork，也可以关注我的简书。]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义view（三）之钟表]]></title>
    <url>%2F2017%2F09%2F13%2F%E8%87%AA%E5%AE%9A%E4%B9%89view%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E9%92%9F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[有时间学习还要有时间总结，感觉学习真是痛苦，痛不欲生、痛苦并快乐着，学会了如果不记下来那么最后的结果就是忘记了，啥也不记得了，以后忘了也没有个地方去查，所以现在我就要做这个工作。其实做表这个demo是17年的8月31号，本来我其实就想画了表盘呢（也是没啥志气），没想到花完感觉空落落的，光秃秃的也不好看，我就想找找看看大家大家的思路是啥，怎么能让那个秒针动弹，然后还真有很简单的方法 postInvalidateDelayed(1000)(我试过这个方法，写1也是1秒，还不知道原理)。如果解决了这个问题那么做一个钟表很简单的，大概思路是这样的： 1.先把画笔的中点移到屏幕中心，画圆，外边画一个方，然后白色的背景就是表盘了，画刻度 2.计算秒针、分针、时针的角度，这就完成了。 先上一个图吧 思路讲完了，现在就是coding了，顺便也说一下一些方法的用法 这就是第一步，把基本的表盘给花出来 private void drawCircle(Canvas canvas) { r = (float) (Math.min(mWidth, mHeight)/2 *0.8); canvas.translate(mWidth/2, mHeight /2);//移动画布中心点到屏幕中央 paint.setColor(getResources().getColor(R.color.brown));//设置画笔的颜色 canvas.drawRect(-r-20,-r-20,r+20,r+20,paint);//画一个正方形，就是外边褐色的框 paint.setColor(getResources().getColor(R.color.black)); paint.setStyle(Paint.Style.FILL);//设置画笔是实心的，画出表盘的圆来 paint.setColor(getResources().getColor(R.color.white)); canvas.drawCircle(0,0,r+5,paint); paint.setStyle(Paint.Style.STROKE);//设置画笔为描边 paint.setColor(getResources().getColor(R.color.black)); paint.setStrokeWidth(1); paint.setTextSize(15); canvas.save();//保存画布 int lineWidth; for (int i = 0; i &lt; 60; i++) {//现在就是要画出表盘的那些个刻度 if (i % 5 == 0) {//是画整点的刻度的，比如12，1，2，3点 paint.setStrokeWidth(3);//设置一下画笔的宽度 lineWidth = 20;//设置整点刻度的线长度 String text = String.valueOf(12 - i/5);//计算当前要填写的数字 Rect textBound = new Rect(); paint.getTextBounds(text, 0, text.length(), textBound); canvas.save(); paint.setStrokeWidth(2); paint.setTextSize(25); paint.setStyle(Paint.Style.FILL); canvas.translate(0,10+lineWidth-r+(textBound.bottom - textBound.top)); canvas.rotate(6 * i);//做一下画布的旋转，这样数字的显示就是正常的哩 canvas.drawText(text, -(textBound.right - textBound.left) / 2,10, paint); canvas.restore(); }else{//画每一分的小刻度的 paint.setStrokeWidth(1); lineWidth = 10; paint.setStrokeWidth(1); } canvas.drawLine(0,-r+10,0,10+lineWidth-r,paint); canvas.rotate(-360/60);//画布逆时针赚 } canvas.restore(); } 表盘花完了就是做最重要的一步了，就是让表动起来，怎么让表动，就是定时的刷新，怎么做定时刷新，其实定时刷新还挺多的用Timer+handler等等一些，现在我就用一个简单的postInvalidateDelayed()方法。 /** * 表的指针 * @param canvas 第一版使用的是60分的，每一秒6度 */ private void drawPointer(Canvas canvas){ Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); //时 int minute = calendar.get(Calendar.MINUTE); //分 int second = calendar.get(Calendar.SECOND); //秒 int angleHour = ((hour % 60) * 360 / 12); //时针转过的角度 int angleMinute = minute * 360 / 60; //分针转过的角度 int angleSecond = second * 360 / 60; //秒针转过的角度 paint.setStyle(Paint.Style.FILL); canvas.save();//分针转动 paint.setColor(getResources().getColor(R.color.black)); canvas.rotate(angleMinute);//旋转画布 angleMinute的角度 RectF rectFMinute = new RectF(-4, -r*2/3, 4, 30); canvas.drawRoundRect(rectFMinute, 10, 10, paint); canvas.restore(); int hourMinute = angleMinute / (6 * 12);//时针转动 if (hourMinute &gt; 0) {//主要实现让时针12分钟转动一格， // 防止时针一小时转一大格不好看 canvas.save(); canvas.rotate(angleHour+hourMinute * 6); RectF rectFHour1 = new RectF(-6, -r/2, 6, 30); canvas.drawRoundRect(rectFHour1, 10, 10, paint); canvas.restore(); }else{ canvas.save(); canvas.rotate(angleHour); RectF rectFHour = new RectF(-6, -r/2, 6, 30); canvas.drawRoundRect(rectFHour, 10, 10, paint); canvas.restore(); } canvas.save();//秒针转动 paint.setColor(getResources().getColor(R.color.red)); canvas.drawCircle(0,0,15,paint); canvas.rotate(angleSecond); RectF rectFSecond = new RectF(-3, -r+5, 3, 30); canvas.drawRoundRect(rectFSecond, 10, 10, paint); canvas.restore(); } 这个是我刚开始的写法，如果这么写就会有一个不好看的地方就是分针每次一小格，感觉太明显了，当然这个问题不是我发现的，是我女朋友说的：那个分针怎么那么转呀，一下跳那么大老远。没办法，女朋友都容忍不了说明是大问题，我就想要不和分针一样，然后就把一小格继续细分让分针实现成一分钟慢慢的调一格也就是6度，12秒钟调一度，5个12秒刚好事一格。 /** * 表的指针 * @param canvas 第二版使用的是每一分下边再细分6度，这样就可以让指针变化的范围更小 */ private void drawPointerSecond(Canvas canvas){ Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); //时 int minute = calendar.get(Calendar.MINUTE); //分 int second = calendar.get(Calendar.SECOND); //秒 int angleHour = ((hour % 60) * 360 / 12); //时针转过的角度 int angleMinute = minute * 360 / 60; //分针转过的角度 int angleSecond = second * 360 / 60; //秒针转过的角度 paint.setStyle(Paint.Style.FILL); int minuteSecond = angleSecond/(6*10); if (minuteSecond&gt;0) { canvas.save();//分针转动 paint.setColor(getResources().getColor(R.color.black)); canvas.rotate(angleMinute + minuteSecond);//旋转画布 angleMinute的角度 RectF rectFMinute = new RectF(-4, -r*2/3, 4, 30); canvas.drawRoundRect(rectFMinute, 10, 10, paint); canvas.restore(); }else{ canvas.save();//分针转动 paint.setColor(getResources().getColor(R.color.black)); canvas.rotate(angleMinute);//旋转画布 angleMinute的角度 RectF rectFMinute = new RectF(-4, -r*2/3, 4, 30); canvas.drawRoundRect(rectFMinute, 10, 10, paint); canvas.restore(); } int hourMinute = angleMinute / (6 * 12);//时针转动 if (hourMinute &gt; 0) {//主要实现让时针12分钟转动一格， // 防止时针一小时转一大格不好看 canvas.save(); canvas.rotate(angleHour+hourMinute * 6); RectF rectFHour1 = new RectF(-6, -r/2, 6, 30); canvas.drawRoundRect(rectFHour1, 10, 10, paint); canvas.restore(); }else{ canvas.save(); canvas.rotate(angleHour); RectF rectFHour = new RectF(-6, -r/2, 6, 30); canvas.drawRoundRect(rectFHour, 10, 10, paint); canvas.restore(); } canvas.save();//秒针转动 paint.setColor(getResources().getColor(R.color.red)); canvas.drawCircle(0,0,15,paint); canvas.rotate(angleSecond); RectF rectFSecond = new RectF(-3, -r+5, 3, 30); canvas.drawRoundRect(rectFSecond, 10, 10, paint); canvas.restore(); } 表就做完了，只要引用到布局文件里就可以了。这是我的git博客,这里是我的git地址欢迎大家star和fork]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义view（二）之学习的资源]]></title>
    <url>%2F2017%2F09%2F13%2F%E8%87%AA%E5%AE%9A%E4%B9%89view%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[自从接触了自定义view之后就想不停的学习，感觉自定义view真是博大精深，这不项目又不忙了，然后我就想开始自己的学习任务，学习首先要有一个好的教材，但是对于程序员来说其实没有什么教材的，任何事物都可以是教材，有时候我看别的app的时候看见一个点，然后就会想我要怎么实现，有时候在网上找，百度不行就google，我觉得我现在遇到的问题前人（没办法，闻到有先后）也遇到过，所以都是这么学习过来的，说了这么多就要说学习资料了，资料不能讲的太深，要适合大多数初学者，我就通过同学的博客找到的，我主要是在GcsSloop大神的博客中学习的，感觉讲的特别好，如果学习进阶的话可以看HenCoder大神的文章，而且最近HenCoder专职在写阶级片，感觉有基础学习他的文章会更上一层楼。今天写到这儿，如果以后有我用到的自定义view的资源再继续纪录。（2017年9月13日）]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义view（一）之ViewDragHelper.Callback]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%87%AA%E5%AE%9A%E4%B9%89view%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BViewDragHelper-Callback%2F</url>
    <content type="text"><![CDATA[1、前言最近开发遇到一个问题，想实现一个日历的控件，可以实现上下拖动展开关闭，可以点击展开关闭， 我找了一些控件也使用了系统的slidingview，但是感觉效果都不怎么好，我在使用slidingview 时候会发生被拖动的view会把下面的页面遮住，是没拖出来的时候已经遮住了，后来在github上 找到一个自己撸的slidingview和slidingview的功能相似。 就是它 2、使用根据业务逻辑要求，或者说我考虑的更全，我有两点修改 2.1、修改打开关闭的回调的位置我在把判断打开关闭放在了ViewDragHelper.Callback的回调里面了，这样判断的话能够更好 的完成的页面（我的应用场景是：当我打开页面的时候，底部的tab栏会隐藏，如果按之前的逻辑 的话tab栏隐藏会造成页面的卡在上边下边会形成空白，我改到完全走完这个动作，然后就不会有 空白） 2.2 添加回弹回调既然有打开和关闭的回调，为啥不能有回弹的回调呢，在回弹里可以加一些逻辑（我有这个业务需 求）。 3、学习既然使用了，那么就要搞懂它的用法，不能只用了，就没事儿了。我感觉这个的主要点有两块，一块 儿是怎么计算这些宽高，另一块儿是ViewDragHelper.Callback的用法，主要也是在这里。现在对 这一块进行学习记录。 首先一点就是ViewDragHelper是一个用作自定义view时候很重要的类，因为在使用自定义的时候会设计到很多的收拾问题，还有很多手势是否拦截的问题，这些问题算起来肯定麻烦，所以系统提供了ViewDragHelper。按google的API中提到的说法：用于允许用户拖放位置的有用操作和状态跟踪视图组中的视图。 public static abstract class Callback { /** * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt; constants * for more information. * * @param state The new drag state * * @see #STATE_IDLE * @see #STATE_DRAGGING * @see #STATE_SETTLING */ public void onViewDragStateChanged(int state) {} /** * Called when the captured view&apos;s position changes as the result of a drag or settle. * * @param changedView View whose position changed * @param left New X coordinate of the left edge of the view * @param top New Y coordinate of the top edge of the view * @param dx Change in X position from the last call * @param dy Change in Y position from the last call */ public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {} /** * Called when a child view is captured for dragging or settling. The ID of the pointer * currently dragging the captured view is supplied. If activePointerId is * identified as {@link #INVALID_POINTER} the capture is programmatic instead of * pointer-initiated. * * @param capturedChild Child view that was captured * @param activePointerId Pointer id tracking the child capture */ public void onViewCaptured(View capturedChild, int activePointerId) {} /** * Called when the child view is no longer being actively dragged. * The fling velocity is also supplied, if relevant. The velocity values may * be clamped to system minimums or maximums. * * &lt;p&gt;Calling code may decide to fling or otherwise release the view to let it * settle into place. It should do so using {@link #settleCapturedViewAt(int, int)} * or {@link #flingCapturedView(int, int, int, int)}. If the Callback invokes * one of these methods, the ViewDragHelper will enter {@link #STATE_SETTLING} * and the view capture will not fully end until it comes to a complete stop. * If neither of these methods is invoked before &lt;code&gt;onViewReleased&lt;/code&gt; returns, * the view will stop in place and the ViewDragHelper will return to * {@link #STATE_IDLE}.&lt;/p&gt; * * @param releasedChild The captured child view now being released * @param xvel X velocity of the pointer as it left the screen in pixels per second. * @param yvel Y velocity of the pointer as it left the screen in pixels per second. */ public void onViewReleased(View releasedChild, float xvel, float yvel) {} /** * Called when one of the subscribed edges in the parent view has been touched * by the user while no child view is currently captured. * * @param edgeFlags A combination of edge flags describing the edge(s) currently touched * @param pointerId ID of the pointer touching the described edge(s) * @see #EDGE_LEFT * @see #EDGE_TOP * @see #EDGE_RIGHT * @see #EDGE_BOTTOM */ public void onEdgeTouched(int edgeFlags, int pointerId) {} /** * Called when the given edge may become locked. This can happen if an edge drag * was preliminarily rejected before beginning, but after {@link #onEdgeTouched(int, int)} * was called. This method should return true to lock this edge or false to leave it * unlocked. The default behavior is to leave edges unlocked. * * @param edgeFlags A combination of edge flags describing the edge(s) locked * @return true to lock the edge, false to leave it unlocked */ public boolean onEdgeLock(int edgeFlags) { return false; } /** * Called when the user has started a deliberate drag away from one * of the subscribed edges in the parent view while no child view is currently captured. * * @param edgeFlags A combination of edge flags describing the edge(s) dragged * @param pointerId ID of the pointer touching the described edge(s) * @see #EDGE_LEFT * @see #EDGE_TOP * @see #EDGE_RIGHT * @see #EDGE_BOTTOM */ public void onEdgeDragStarted(int edgeFlags, int pointerId) {} /** * Called to determine the Z-order of child views. * * @param index the ordered position to query for * @return index of the view that should be ordered at position &lt;code&gt;index&lt;/code&gt; */ public int getOrderedChildIndex(int index) { return index; } /** * Return the magnitude of a draggable child view&apos;s horizontal range of motion in pixels. * This method should return 0 for views that cannot move horizontally. * * @param child Child view to check * @return range of horizontal motion in pixels */ public int getViewHorizontalDragRange(View child) { return 0; } /** * Return the magnitude of a draggable child view&apos;s vertical range of motion in pixels. * This method should return 0 for views that cannot move vertically. * * @param child Child view to check * @return range of vertical motion in pixels */ public int getViewVerticalDragRange(View child) { return 0; } /** * Called when the user&apos;s input indicates that they want to capture the given child view * with the pointer indicated by pointerId. The callback should return true if the user * is permitted to drag the given view with the indicated pointer. * * &lt;p&gt;ViewDragHelper may call this method multiple times for the same view even if * the view is already captured; this indicates that a new pointer is trying to take * control of the view.&lt;/p&gt; * * &lt;p&gt;If this method returns true, a call to {@link #onViewCaptured(android.view.View, int)} * will follow if the capture is successful.&lt;/p&gt; * * @param child Child the user is attempting to capture * @param pointerId ID of the pointer attempting the capture * @return true if capture should be allowed, false otherwise */ public abstract boolean tryCaptureView(View child, int pointerId); /** * Restrict the motion of the dragged child view along the horizontal axis. * The default implementation does not allow horizontal motion; the extending * class must override this method and provide the desired clamping. * * * @param child Child view being dragged * @param left Attempted motion along the X axis * @param dx Proposed change in position for left * @return The new clamped position for left */ public int clampViewPositionHorizontal(View child, int left, int dx) { return 0; } /** * Restrict the motion of the dragged child view along the vertical axis. * The default implementation does not allow vertical motion; the extending * class must override this method and provide the desired clamping. * * * @param child Child view being dragged * @param top Attempted motion along the Y axis * @param dy Proposed change in position for top * @return The new clamped position for top */ public int clampViewPositionVertical(View child, int top, int dy) { return 0; } } onViewDragStateChanged(int state) 这个方法是用来返回拖动状态的，共有三种状态 STATE_IDLE、STATE_DRAGGING、STATE_SETTLING（拖动停止0、手指拖动中1、自动滚动2）。onViewPositionChanged(View changedView, int left, int top, int dx, int dy)这个方法是对于changdeView的位置发生变化的回调。onViewCaptured(View capturedChild, int activePointerId)文档中写view被捕捉到拖拽或定居时被调用。onViewReleased(View releasedChild, float xvel, float yvel) 当手指释放，不在拖动时的回调，xvel和yvel是拖动的速度。onEdgeTouched(int edgeFlags, int pointerId)触摸到边界时的回调，edgeFlags有左、上、右、下四个方向。boolean onEdgeLock(int edgeFlags) 当给定的边界被锁定的时候，true为被锁定，false被解锁。onEdgeDragStarted(int edgeFlags, int pointerId)当边界被拖动时候的回调。int getOrderedChildIndex(int index)z方向上子view的调用顺序。index为z方向的位置，返回值为该位置的view。int getViewHorizontalDragRange(View child) 返回值为0则横向不可拖动点击。int getViewVerticalDragRange(View child) 返回值为0则竖直方向不可拖动点击。boolean tryCaptureView(View child, int pointerId)child为可拖动view，如果返回true则可拖动，返回false不可拖动。int clampViewPositionHorizontal(View child, int left, int dx) 水平位置的拖动范围限制，返回值为限制的值。int clampViewPositionVertical(View child, int top, int dy) 竖直位置的拖动范围限制，返回值为限制的值。基本方法理解了，下一步就是进行demo了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[米UI弹窗的问题]]></title>
    <url>%2F2017%2F07%2F13%2F%E7%B1%B3UI%E5%BC%B9%E7%AA%97%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[因为小米对系统的深度定制，所以米UI有很多的问题和Android开发是不一样的，这里纪录一下我之前发现的问题。当升级到miui7的时候发现想要弹出系统级的弹窗（就是那种弹出之后怎么也消失不了的，除非关机，一般用于强制更新）已经不可能了，后来发现原因在于MIUI把这一项作为了系统权限。后来为了实现弹出这个弹窗只能引导用户来开启这个权限（如果我是用户一定想哭）。步骤分为四步走 判断是不是小米 –&gt; 判断MIUI版本 –&gt; 判断有没有开启弹窗权限 –&gt; 跳转到应用设置页 第一步 判断是不是小米 private boolean isMIUI() { String brand = Build.BRAND.toString(); if (&quot;Xiaomi&quot;.equalsIgnoreCase(brand)) { return true; } return false; } 第二步 判断MIUI版本 String miUiVersion = getSystemProperty(&quot;ro.miui.ui.version.name&quot;); public static String getSystemProperty(String propName) { String line; BufferedReader input = null; try { Process p = Runtime.getRuntime().exec(&quot;getprop &quot; + propName); input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); } catch (IOException ex) { Logger.e(&quot;&quot;, &quot;Unable to read sysprop &quot; + propName, ex); return null; } finally { if (input != null) { try { input.close(); } catch (IOException e) { Logger.e(&quot;&quot;, &quot;Exception while closing InputStream&quot;, e); } } } return line; } 第三步 判断有没有开启弹窗权限 if(isMiuiFloaAllowed(context)){ getAppDetailSettingIntent(context); } public boolean isMiuiFloaAllowed(Context context) { if (isMIUI()) { return checkOp(context); } else { return false; } } private boolean checkOp(Context context) { try { if (AppOpsManager.MODE_ALLOWED == op(context)) { return true; } else { return false; } } catch (Exception e) { e.printStackTrace(); return false; } } private static ApplicationInfo localApplicationInfo1 = null; private int op(Context context) { if (Build.VERSION.SDK_INT &gt;= 19){ try { Object localObject = context .getSystemService(APP_OPS_SERVICE); Class localClass = localObject.getClass(); Class[] arrayOfClass = new Class[3]; arrayOfClass[0] = Integer.TYPE; arrayOfClass[1] = Integer.TYPE; arrayOfClass[2] = String.class; Method localMethod = localClass.getMethod(&quot;checkOp&quot;, arrayOfClass); Object[] arrayOfObject = new Object[3]; arrayOfObject[0] = Integer.valueOf(24); arrayOfObject[1] = Integer.valueOf(Binder.getCallingUid()); arrayOfObject[2] = context.getPackageName(); int j = ((Integer) localMethod.invoke(localObject, arrayOfObject)).intValue(); if (j == 0) return 1; return 0; } catch (Throwable localThrowable2) { return -1; } }else{//19以下的版本的特殊处理 ActivityManager am = (ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE); ComponentName cn = am.getRunningTasks(1).get(0).topActivity; if(!&quot;com.cdel.internal.mobile&quot;.equalsIgnoreCase(cn.getPackageName())){ try { ApplicationInfo localApplicationInfo2 = BaseApplication .getInstance() .getPackageManager() .getApplicationInfo(context.getPackageName(), 0); localApplicationInfo1 = localApplicationInfo2; if (localApplicationInfo1 != null) { if ((0x8000000 &amp; localApplicationInfo1.flags) == 0) return 0; } } catch (Throwable localThrowable1) { while (true) localApplicationInfo1 = null; } } return -1; } } 第四步 跳转到应用设置页 private void getAppDetailSettingIntent(Context context) { Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= 9) { localIntent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;); localIntent.setData(Uri.fromParts(&quot;package&quot;, BaseApplication.getInstance().getPackageName(), null)); } else if (Build.VERSION.SDK_INT &lt;= 8) { localIntent.setAction(Intent.ACTION_VIEW); localIntent.setClassName(&quot;com.android.settings&quot;,&quot;com.android.settings.InstalledAppDetails&quot;); localIntent.putExtra(&quot;com.android.settings.ApplicationPkgName&quot;, BaseApplication.getInstance().getPackageName()); } context.startActivity(localIntent); Toast.makeText(context,&quot;为了展示消息请您在&lt;权限管理&gt;--&gt;&lt;显示悬浮窗&gt;设置悬浮窗权限&quot;,Toast.LENGTH_LONG).show(); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发中的一些知识点（持续更新）]]></title>
    <url>%2F2017%2F07%2F13%2FAndroid-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.过度绘制绘制颜色的标识，从好到差：蓝色(1x次绘制) –&gt; 浅绿色(2x绘制) –&gt; 淡红色(3x绘制) –&gt; 红色(4x绘制)。 2.glide 获取缓存图片并存储new Thread(new Runnable() { @Override public void run() { try { File file = Glide.with(XxqApplication.mContext) .load(avatar) .downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL) .get(); Log.d(TAG, &quot;run: &quot;); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }}).start(); private class SaveImageTask extends AsyncTask&lt;String, Void, File&gt; { private final Context context; public SaveImageTask(Context context) { this.context = context; } @Override protected File doInBackground(String... params) { String imgUrl = params[0]; try { return } catch (Exception ex) { return null; } } @Override protected void onPostExecute(File result) { if (result == null) { return; } //此path就是对应文件的缓存路径 String path = result.getPath(); //将缓存文件copy, 命名为图片格式文件 copyFile(path, newPath); }} /*** oldPath: 图片缓存的路径 * newPath: 图片缓存copy的路径 */ public static void copyFile(String oldPath, String newPath) { try { int byteRead; File oldFile = new File(oldPath); if (oldFile.exists()) { InputStream inStream = new FileInputStream(oldPath); FileOutputStream fs = new FileOutputStream(newPath); byte[] buffer = new byte[1024]; while ( (byteRead = inStream.read(buffer)) != -1) { fs.write(buffer, 0, byteRead); } inStream.close(); } } catch (Exception e) { System.out.println(&quot;复制文件操作出错&quot;); e.printStackTrace(); }} 3.华为荣耀6plus不能打印日志的问题拨号界面：##2846579## 工程菜单-&gt;后台设置-&gt;Log设置-&gt;选择第一个AP日志 ok了，重启应用就可以了，不需要重启手机。 4.TextView的旋转问题我之前开发遇到一个问题，teamLeader让把一个页面的的展示变成斜着的，我之前知道有这种功能但是不知道怎么实现，后来到网上找了一些，然后看了一下，都是要重写TextView的方法才能实现，后来发现textView有一个属性就是可以做旋转的，当当当，rotation闪亮登场了，没错他就是旋转，只要在xml中设置就可以了。 5.命令安装App进去apk所在目录下，shift+鼠标右键–&gt;选择“在此处打开命令窗口”，输入：“adb install -r ”把文件拖入，完成。可能出现的问题，adb不是命令，在环境变量自己的用户变量中配置环境变量：配置为sdk下的\platform-tools F:\ProgramFiles\Android\AndroidStudio_SDK\AndroidStudio_green\platform-tools 6.androidStudio遇到more than one library with package name‘com.xxx.xx’错误原因是‘com.xxx.xx’被多引用了，引用超过一次。我遇到的情况是，app中引用了相同的arr包报错，找了好久才知道。 7.直接打开微信的扫一扫今天看到了一个博客，发现一个可以打开微信二维码的纪录，想看原文在这里代码如下 public static void toWeChatScanDirect(Context context) { try { Intent intent = new Intent(); intent.setComponent(new ComponentName(&quot;com.tencent.mm&quot;, &quot;com.tencent.mm.ui.LauncherUI&quot;)); intent.putExtra(&quot;LauncherUI.From.Scaner.Shortcut&quot;, true); intent.setFlags(335544320); intent.setAction(&quot;android.intent.action.VIEW&quot;); context.startActivity(intent); } catch (Exception e) { } } 8.判断app的SHA1的值是否正确，一般用作高德或百度地图的判断直接上代码 /** * 获取应用的 SHA1 值， 可据此判断高德，百度地图 key 是否正确 * * @param context 上下文 * @return 应用的 SHA1 字符串, 比如： 53:FD:54:DC:19:0F:11:AC:B5:22:9E:F1:1A:68:88:1B:8B:E8:54:42 */ public static String getSHA1(Context context) { try { PackageInfo info = context.getPackageManager().getPackageInfo( context.getPackageName(), PackageManager.GET_SIGNATURES); byte[] cert = info.signatures[0].toByteArray(); MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;); byte[] publicKey = md.digest(cert); StringBuilder hexString = new StringBuilder(); for (byte aPublicKey : publicKey) { String appendString = Integer.toHexString(0xFF &amp; aPublicKey).toUpperCase(); if (appendString.length() == 1) hexString.append(&quot;0&quot;); hexString.append(appendString); hexString.append(&quot;:&quot;); } String result = hexString.toString(); return result.substring(0, result.length() - 1); } catch (PackageManager.NameNotFoundException | NoSuchAlgorithmException e) { e.printStackTrace(); } return &quot;&quot;; }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F07%2F03%2Ffi'r'se%2F</url>
    <content type="text"><![CDATA[第一篇博客 这是我写的第一篇博客，今天看见之前的同学做好他的github上的静态博客，感觉有点儿受刺激了， 4月的时候我也搞过一段时间这个，但是之后觉得不好麻烦就放弃了，现在就对比就想搞了， 感觉搞一个以后如果给别人介绍的时候也可以告诉人家我的博客在哪儿哪儿，网址给你， 看一下吧，嘎嘎，还有感觉做一个博客也能督促自己写一些专业的博客，以后积累技术的经验。 以后有时间慢慢更新，这算是一个好的开头吧，万事开头难！]]></content>
  </entry>
</search>