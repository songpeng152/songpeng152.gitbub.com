<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义view（一）之ViewDragHelper.Callback]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%87%AA%E5%AE%9A%E4%B9%89view%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BViewDragHelper-Callback%2F</url>
    <content type="text"><![CDATA[1、前言最近开发遇到一个问题，想实现一个日历的控件，可以实现上下拖动展开关闭，可以点击展开关闭， 我找了一些控件也使用了系统的slidingview，但是感觉效果都不怎么好，我在使用slidingview 时候会发生被拖动的view会把下面的页面遮住，是没拖出来的时候已经遮住了，后来在github上 找到一个自己撸的slidingview和slidingview的功能相似。 就是它 2、使用根据业务逻辑要求，或者说我考虑的更全，我有两点修改 2.1、修改打开关闭的回调的位置我在把判断打开关闭放在了ViewDragHelper.Callback的回调里面了，这样判断的话能够更好 的完成的页面（我的应用场景是：当我打开页面的时候，底部的tab栏会隐藏，如果按之前的逻辑 的话tab栏隐藏会造成页面的卡在上边下边会形成空白，我改到完全走完这个动作，然后就不会有 空白） 2.2 添加回弹回调既然有打开和关闭的回调，为啥不能有回弹的回调呢，在回弹里可以加一些逻辑（我有这个业务需 求）。 3、学习既然使用了，那么就要搞懂它的用法，不能只用了，就没事儿了。我感觉这个的主要点有两块，一块 儿是怎么计算这些宽高，另一块儿是ViewDragHelper.Callback的用法，主要也是在这里。现在对 这一块进行学习记录。 首先一点就是ViewDragHelper是一个用作自定义view时候很重要的类，因为在使用自定义的时候会设计到很多的收拾问题，还有很多手势是否拦截的问题，这些问题算起来肯定麻烦，所以系统提供了ViewDragHelper。按google的API中提到的说法：用于允许用户拖放位置的有用操作和状态跟踪视图组中的视图。 public static abstract class Callback { /** * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt; constants * for more information. * * @param state The new drag state * * @see #STATE_IDLE * @see #STATE_DRAGGING * @see #STATE_SETTLING */ public void onViewDragStateChanged(int state) {} /** * Called when the captured view&apos;s position changes as the result of a drag or settle. * * @param changedView View whose position changed * @param left New X coordinate of the left edge of the view * @param top New Y coordinate of the top edge of the view * @param dx Change in X position from the last call * @param dy Change in Y position from the last call */ public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {} /** * Called when a child view is captured for dragging or settling. The ID of the pointer * currently dragging the captured view is supplied. If activePointerId is * identified as {@link #INVALID_POINTER} the capture is programmatic instead of * pointer-initiated. * * @param capturedChild Child view that was captured * @param activePointerId Pointer id tracking the child capture */ public void onViewCaptured(View capturedChild, int activePointerId) {} /** * Called when the child view is no longer being actively dragged. * The fling velocity is also supplied, if relevant. The velocity values may * be clamped to system minimums or maximums. * * &lt;p&gt;Calling code may decide to fling or otherwise release the view to let it * settle into place. It should do so using {@link #settleCapturedViewAt(int, int)} * or {@link #flingCapturedView(int, int, int, int)}. If the Callback invokes * one of these methods, the ViewDragHelper will enter {@link #STATE_SETTLING} * and the view capture will not fully end until it comes to a complete stop. * If neither of these methods is invoked before &lt;code&gt;onViewReleased&lt;/code&gt; returns, * the view will stop in place and the ViewDragHelper will return to * {@link #STATE_IDLE}.&lt;/p&gt; * * @param releasedChild The captured child view now being released * @param xvel X velocity of the pointer as it left the screen in pixels per second. * @param yvel Y velocity of the pointer as it left the screen in pixels per second. */ public void onViewReleased(View releasedChild, float xvel, float yvel) {} /** * Called when one of the subscribed edges in the parent view has been touched * by the user while no child view is currently captured. * * @param edgeFlags A combination of edge flags describing the edge(s) currently touched * @param pointerId ID of the pointer touching the described edge(s) * @see #EDGE_LEFT * @see #EDGE_TOP * @see #EDGE_RIGHT * @see #EDGE_BOTTOM */ public void onEdgeTouched(int edgeFlags, int pointerId) {} /** * Called when the given edge may become locked. This can happen if an edge drag * was preliminarily rejected before beginning, but after {@link #onEdgeTouched(int, int)} * was called. This method should return true to lock this edge or false to leave it * unlocked. The default behavior is to leave edges unlocked. * * @param edgeFlags A combination of edge flags describing the edge(s) locked * @return true to lock the edge, false to leave it unlocked */ public boolean onEdgeLock(int edgeFlags) { return false; } /** * Called when the user has started a deliberate drag away from one * of the subscribed edges in the parent view while no child view is currently captured. * * @param edgeFlags A combination of edge flags describing the edge(s) dragged * @param pointerId ID of the pointer touching the described edge(s) * @see #EDGE_LEFT * @see #EDGE_TOP * @see #EDGE_RIGHT * @see #EDGE_BOTTOM */ public void onEdgeDragStarted(int edgeFlags, int pointerId) {} /** * Called to determine the Z-order of child views. * * @param index the ordered position to query for * @return index of the view that should be ordered at position &lt;code&gt;index&lt;/code&gt; */ public int getOrderedChildIndex(int index) { return index; } /** * Return the magnitude of a draggable child view&apos;s horizontal range of motion in pixels. * This method should return 0 for views that cannot move horizontally. * * @param child Child view to check * @return range of horizontal motion in pixels */ public int getViewHorizontalDragRange(View child) { return 0; } /** * Return the magnitude of a draggable child view&apos;s vertical range of motion in pixels. * This method should return 0 for views that cannot move vertically. * * @param child Child view to check * @return range of vertical motion in pixels */ public int getViewVerticalDragRange(View child) { return 0; } /** * Called when the user&apos;s input indicates that they want to capture the given child view * with the pointer indicated by pointerId. The callback should return true if the user * is permitted to drag the given view with the indicated pointer. * * &lt;p&gt;ViewDragHelper may call this method multiple times for the same view even if * the view is already captured; this indicates that a new pointer is trying to take * control of the view.&lt;/p&gt; * * &lt;p&gt;If this method returns true, a call to {@link #onViewCaptured(android.view.View, int)} * will follow if the capture is successful.&lt;/p&gt; * * @param child Child the user is attempting to capture * @param pointerId ID of the pointer attempting the capture * @return true if capture should be allowed, false otherwise */ public abstract boolean tryCaptureView(View child, int pointerId); /** * Restrict the motion of the dragged child view along the horizontal axis. * The default implementation does not allow horizontal motion; the extending * class must override this method and provide the desired clamping. * * * @param child Child view being dragged * @param left Attempted motion along the X axis * @param dx Proposed change in position for left * @return The new clamped position for left */ public int clampViewPositionHorizontal(View child, int left, int dx) { return 0; } /** * Restrict the motion of the dragged child view along the vertical axis. * The default implementation does not allow vertical motion; the extending * class must override this method and provide the desired clamping. * * * @param child Child view being dragged * @param top Attempted motion along the Y axis * @param dy Proposed change in position for top * @return The new clamped position for top */ public int clampViewPositionVertical(View child, int top, int dy) { return 0; } } onViewDragStateChanged(int state) 这个方法是用来返回拖动状态的，共有三种状态 STATE_IDLE、STATE_DRAGGING、STATE_SETTLING（拖动停止0、手指拖动中1、自动滚动2）。onViewPositionChanged(View changedView, int left, int top, int dx, int dy)这个方法是对于changdeView的位置发生变化的回调。onViewCaptured(View capturedChild, int activePointerId)文档中写view被捕捉到拖拽或定居时被调用。onViewReleased(View releasedChild, float xvel, float yvel) 当手指释放，不在拖动时的回调，xvel和yvel是拖动的速度。onEdgeTouched(int edgeFlags, int pointerId)触摸到边界时的回调，edgeFlags有左、上、右、下四个方向。boolean onEdgeLock(int edgeFlags) 当给定的边界被锁定的时候，true为被锁定，false被解锁。onEdgeDragStarted(int edgeFlags, int pointerId)当边界被拖动时候的回调。int getOrderedChildIndex(int index)z方向上子view的调用顺序。index为z方向的位置，返回值为该位置的view。int getViewHorizontalDragRange(View child) 返回值为0则横向不可拖动点击。int getViewVerticalDragRange(View child) 返回值为0则竖直方向不可拖动点击。boolean tryCaptureView(View child, int pointerId)child为可拖动view，如果返回true则可拖动，返回false不可拖动。int clampViewPositionHorizontal(View child, int left, int dx) 水平位置的拖动范围限制，返回值为限制的值。int clampViewPositionVertical(View child, int top, int dy) 竖直位置的拖动范围限制，返回值为限制的值。基本方法理解了，下一步就是进行demo了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[米UI弹窗的问题]]></title>
    <url>%2F2017%2F07%2F13%2F%E7%B1%B3UI%E5%BC%B9%E7%AA%97%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[因为小米对系统的深度定制，所以米UI有很多的问题和Android开发是不一样的，这里纪录一下我之前发现的问题。当升级到miui7的时候发现想要弹出系统级的弹窗（就是那种弹出之后怎么也消失不了的，除非关机，一般用于强制更新）已经不可能了，后来发现原因在于MIUI把这一项作为了系统权限。后来为了实现弹出这个弹窗只能引导用户来开启这个权限（如果我是用户一定想哭）。步骤分为四步走 判断是不是小米 –&gt; 判断MIUI版本 –&gt; 判断有没有开启弹窗权限 –&gt; 跳转到应用设置页 第一步 判断是不是小米 private boolean isMIUI() { String brand = Build.BRAND.toString(); if (&quot;Xiaomi&quot;.equalsIgnoreCase(brand)) { return true; } return false; } 第二步 判断MIUI版本 String miUiVersion = getSystemProperty(&quot;ro.miui.ui.version.name&quot;); public static String getSystemProperty(String propName) { String line; BufferedReader input = null; try { Process p = Runtime.getRuntime().exec(&quot;getprop &quot; + propName); input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); } catch (IOException ex) { Logger.e(&quot;&quot;, &quot;Unable to read sysprop &quot; + propName, ex); return null; } finally { if (input != null) { try { input.close(); } catch (IOException e) { Logger.e(&quot;&quot;, &quot;Exception while closing InputStream&quot;, e); } } } return line; } 第三步 判断有没有开启弹窗权限 if(isMiuiFloaAllowed(context)){ getAppDetailSettingIntent(context); } public boolean isMiuiFloaAllowed(Context context) { if (isMIUI()) { return checkOp(context); } else { return false; } } private boolean checkOp(Context context) { try { if (AppOpsManager.MODE_ALLOWED == op(context)) { return true; } else { return false; } } catch (Exception e) { e.printStackTrace(); return false; } } private static ApplicationInfo localApplicationInfo1 = null; private int op(Context context) { if (Build.VERSION.SDK_INT &gt;= 19){ try { Object localObject = context .getSystemService(APP_OPS_SERVICE); Class localClass = localObject.getClass(); Class[] arrayOfClass = new Class[3]; arrayOfClass[0] = Integer.TYPE; arrayOfClass[1] = Integer.TYPE; arrayOfClass[2] = String.class; Method localMethod = localClass.getMethod(&quot;checkOp&quot;, arrayOfClass); Object[] arrayOfObject = new Object[3]; arrayOfObject[0] = Integer.valueOf(24); arrayOfObject[1] = Integer.valueOf(Binder.getCallingUid()); arrayOfObject[2] = context.getPackageName(); int j = ((Integer) localMethod.invoke(localObject, arrayOfObject)).intValue(); if (j == 0) return 1; return 0; } catch (Throwable localThrowable2) { return -1; } }else{//19以下的版本的特殊处理 ActivityManager am = (ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE); ComponentName cn = am.getRunningTasks(1).get(0).topActivity; if(!&quot;com.cdel.internal.mobile&quot;.equalsIgnoreCase(cn.getPackageName())){ try { ApplicationInfo localApplicationInfo2 = BaseApplication .getInstance() .getPackageManager() .getApplicationInfo(context.getPackageName(), 0); localApplicationInfo1 = localApplicationInfo2; if (localApplicationInfo1 != null) { if ((0x8000000 &amp; localApplicationInfo1.flags) == 0) return 0; } } catch (Throwable localThrowable1) { while (true) localApplicationInfo1 = null; } } return -1; } } 第四步 跳转到应用设置页 private void getAppDetailSettingIntent(Context context) { Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= 9) { localIntent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;); localIntent.setData(Uri.fromParts(&quot;package&quot;, BaseApplication.getInstance().getPackageName(), null)); } else if (Build.VERSION.SDK_INT &lt;= 8) { localIntent.setAction(Intent.ACTION_VIEW); localIntent.setClassName(&quot;com.android.settings&quot;,&quot;com.android.settings.InstalledAppDetails&quot;); localIntent.putExtra(&quot;com.android.settings.ApplicationPkgName&quot;, BaseApplication.getInstance().getPackageName()); } context.startActivity(localIntent); Toast.makeText(context,&quot;为了展示消息请您在&lt;权限管理&gt;--&gt;&lt;显示悬浮窗&gt;设置悬浮窗权限&quot;,Toast.LENGTH_LONG).show(); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发中的一些知识点]]></title>
    <url>%2F2017%2F07%2F13%2FAndroid-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.过度绘制绘制颜色的标识，从好到差：蓝色(1x次绘制) –&gt; 浅绿色(2x绘制) –&gt; 淡红色(3x绘制) –&gt; 红色(4x绘制)。 2.glide 获取缓存图片并存储new Thread(new Runnable() { @Override public void run() { try { File file = Glide.with(XxqApplication.mContext) .load(avatar) .downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL) .get(); Log.d(TAG, &quot;run: &quot;); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }}).start(); private class SaveImageTask extends AsyncTask&lt;String, Void, File&gt; { private final Context context; public SaveImageTask(Context context) { this.context = context; } @Override protected File doInBackground(String... params) { String imgUrl = params[0]; try { return } catch (Exception ex) { return null; } } @Override protected void onPostExecute(File result) { if (result == null) { return; } //此path就是对应文件的缓存路径 String path = result.getPath(); //将缓存文件copy, 命名为图片格式文件 copyFile(path, newPath); }} /*** oldPath: 图片缓存的路径 * newPath: 图片缓存copy的路径 */ public static void copyFile(String oldPath, String newPath) { try { int byteRead; File oldFile = new File(oldPath); if (oldFile.exists()) { InputStream inStream = new FileInputStream(oldPath); FileOutputStream fs = new FileOutputStream(newPath); byte[] buffer = new byte[1024]; while ( (byteRead = inStream.read(buffer)) != -1) { fs.write(buffer, 0, byteRead); } inStream.close(); } } catch (Exception e) { System.out.println(&quot;复制文件操作出错&quot;); e.printStackTrace(); }} 华为荣耀6plus不能打印日志的问题拨号界面：##2846579## 工程菜单-&gt;后台设置-&gt;Log设置-&gt;选择第一个AP日志 ok了，重启应用就可以了，不需要重启手机。 4.TextView的旋转问题我之前开发遇到一个问题，teamLeader让把一个页面的的展示变成斜着的，我之前知道有这种功能但是不知道怎么实现，后来到网上找了一些，然后看了一下，都是要重写TextView的方法才能实现，后来发现textView有一个属性就是可以做旋转的，当当当，rotation闪亮登场了，没错他就是旋转，只要在xml中设置就可以了。 5.命令安装App进去apk所在目录下，shift+鼠标右键–&gt;选择“在此处打开命令窗口”，输入：“adb install -r ”把文件拖入，完成。可能出现的问题，adb不是命令，在环境变量自己的用户变量中配置环境变量：配置为sdk下的\platform-tools F:\ProgramFiles\Android\AndroidStudio_SDK\AndroidStudio_green\platform-tools 6.androidStudio遇到more than one library with package name‘com.xxx.xx’错误原因是‘com.xxx.xx’被多引用了，引用超过一次。我遇到的情况是，app中引用了相同的arr包报错，找了好久才知道。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F07%2F03%2Ffi'r'se%2F</url>
    <content type="text"><![CDATA[第一篇博客 这是我写的第一篇博客，今天看见之前的同学做好他的github上的静态博客，感觉有点儿受刺激了， 4月的时候我也搞过一段时间这个，但是之后觉得不好麻烦就放弃了，现在就对比就想搞了， 感觉搞一个以后如果给别人介绍的时候也可以告诉人家我的博客在哪儿哪儿，网址给你， 看一下吧，嘎嘎，还有感觉做一个博客也能督促自己写一些专业的博客，以后积累技术的经验。 以后有时间慢慢更新，这算是一个好的开头吧，万事开头难！]]></content>
  </entry>
</search>